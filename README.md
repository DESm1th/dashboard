The dashboard webapp provides an overview of the studies supported by the kimel
lab. The app supports manual QC of MRI sessions as well as display of various
QC metrics generated by our nightly pipelines.

## Table of Contents
1. [Technologies](#technologies)
2. [TIGRLab Ansible Configuration](#tigrlab-ansible-configuration)  
  * [Dashboard Role](#dashboard-role)  
    * [dashboard_ini_template.j2](#dashboard_ini_template.j2)
    * [dashboard.ini.j2](#dashboard.ini.j2)
  * [Postgres Role](#postgres-role)  
    * [Postgresql Configuration](#postgresql-configuration)
    * [Backups](#backups)



## Technologies

The app is supported by a backend [postgreSQL](https://www.postgresql.org/)
database, hosted on the srv-postgres.camhres.ca virtual server. The front end is
programmed in python using the [Flask](http://flask.pocoo.org/) framework, with
[SQLAlchemy](https://www.sqlalchemy.org/). The web server itself is
[NGINX](https://www.nginx.com/) with
[UWSGI](https://uwsgi-docs.readthedocs.io/en/latest/). Authentication is handled
with [OAuth](https://en.wikipedia.org/wiki/OAuth) and we currently support
github and gitlab for login.

## Dashboard Structure

## Creating a Development Environment

## Database Tips

## Modifying the Production Dashboard

### Adding a New Study (Part of modifying production dashboard)

## TIGRLab Ansible Configuration

For our lab, the dashboard's configuration can be found in the role 'dashboard'
and srv-postgres' configuration is in the role 'postgres'. This section is
only relevant for TIGRLab dashboard admins :)

### Dashboard Role
The most important thing this role does is add the UWSGI and NGINX configuration
for the dashboard to srv-dashboard. The NGINX configuration is just a copy
of `dashboard/templates/nginx_dashboard.conf.j2` while the UWSGI configuration
is generated from `dashboard/templates/dashboard_ini_template.j2` and
`dashboard/templates/dashboard.ini.j2`.

**NOTE**: If you make any configuration changes directly to srv-dashboard
without adding these changes to ansible your changes may be obliterated  the
next time ansible is run. Also, it's just generally bad practice and makes it
harder to recreate a working server if anything catastrophic happens.
**Dont do this!**

#### dashboard_ini_template.j2
This file is the main source for UWSGI configuration. It holds all of the
non-sensitive settings for the server. New environment variables and changes
to how UWSGI will run should be added here.

#### dashboard.ini.j2
This file holds sensitive information that gets filled in to the
"dashboard_ini_template.j2" template. It is stored separately in a
directory that we never commit to github and linked into the templates folder.
Any new passwords or secrets should be added here and a line added to
"dashboard_ini_template.j2" where the new secret will be filled in.

### Postgres Role
The most important tasks this role performs are configuring postgresql for
the dashboard and configuring database backups.

#### PostgreSQL Configuration
# TBA
As with the dashboard role (and anything managed by ansible), configuration
changes should be made in ansible not directly to the server.

#### Backups
Ansible configures a cron job (`/etc/cron.d/dashboard_bkup`) that will dump the
entire database nightly and store the result in `/mnt/backup` on srv-postgres.
We currently keep three weeks worth of backups. TIGRsrv is configured to copy
the backups and store them at `/mnt/backup/dashboard`. So we should have two
copies at all times.










### Database

* *Server:* srv-postgres.camhres.ca (172.26.216.68)
* *Database:* dashboard

Server is **ansible** managed by role `/projects/admin/ansible-playbooks/roles/postgres`

Access requires postgresql client and pidentd both be installed. To configure
authentication for a user an entry must be added to pg_ident.conf
mapping their system user name to web_user. A 'catch all' entry must be present as
well to allow users to access the database as themselves.

So as an example, you could add the following to pg_ident.conf and the user
dawn would have passwordless access to postgres as 'dawn' and as 'web_user':

```
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME
default		      dawn                    web_user
default         /(.*)                   \1
```

The **postgres** user (local machine) has SUPERUSER, by default other users have no access.

Three _roles_ have been defined with access to the dashboard database.

* **admin:** Manage databases, manage roles on all databases
* **dashboard:** Read, Write, Delete etc. on dashboard database
* **dashboard_read:** Read only on dashboard database

One special _user_ role has been defined. **web_user**, this is a member of the **dashboard** role and is used by the webapp front end.

**Clevis** is defined as a superuser to enable backups.

**N.B.** SQL commands are not case sensitive, but are normally terminated with a **; (semi-colon)**.

#### Backups
Backups are performed as user __clevis__ from a cron job `/etc/cron.d/ansible_postgres-backup` running on `srv_postgres`.
_Requires:_ `/mnt/backup` exported from tigrsrv, with a subdirectory `postgres` with write permission for user __clevis__.

##### Restoring from backup
```
$ psql -f /mnt/backup/postgres/postgres_YYYYMMDD.sql dashboard
```

#### Grant admin rights to a user:

Required to manage other users.

```
$ ssh localadmin@srv-postgres
$ sudo su postgres
$ psql -d dashboard
dashboard=# GRANT admin TO <username>;
GRANT ROLE
dashboard=# \q
$
```

#### Grant Read only access to the dashboard database

To grant roles to other users, the current user must have the CREATE ROLE attribute, i.e. be a member of the _admin_ ROLE.

Once a user has been created in the database, access can be obtained from a local machine without requirement to ssh.

```
$ psql -h srv-postgres -d dashboard
dashboard=# GRANT dashboard_read TO <username>;
GRANT ROLE
dashboard=# \q
$
```

### Webserver

* **Server:** srv-dashboard.camhres.ca (172.26.216.66)

**NGINX** and **UWSGI** configuration are controlled by the ansible role `/projects/admin/ansible-playbooks/roles/dashboard/`.

The uwsgi app runs as user **clevis** with the **web_user** to access the database. These are configured in ```/etc/uwsgi/apps-available/dashboard.ini``` (Ansible controlled).

The codebase is expected to be located at `/archive/code/dashboard`.

*Important:* Some secret information is required in the ansible controlled file ``/etc/uwsgi/apps-available/dashboard.ini`. These entries should not be committed to github. The relevant passwords are in passpack.

#### Virtual env

The dashboard webapp depends on a python virtual env. Once the repo has been cloned from github create the virtual env and install the requirements.

Note: if the cryptography python package fails to install, make sure you have libssl-dev installed

```
$ git clone git@github.com:TIGRLab/dashboard.git dashboard
$ cd dashboard
$ virtualenv -p /usr/bin/python2.7 venv
$ source venv/bin/activate
$ pip install -r requirements.txt
```

### Web-app

**GitHub:** https://github.com/TIGRLab/dashboard

The app is written in python, using the Flask framework with SQLAlchemy.

#### Overview

`dashboard/models.py` defines the _Object Relational Mapping (ORM)_ used by SQLAlchemy to map from the relational database to the python objects used in the code.

`dashboard/views.py` defines the _entry points_ (i.e. valid URLs for the app).

HTML templates are in `dashboard/templates/`. Templates with `_snip.html` are embedded in other pages.

The web-app interacts with the filesystem (checklist.csv, blacklist.csv), updates made through the web-app are automatically propogated to the filesystem before the update is made. If the filesystem cannot be updated the database update fails.
Alterations made to the filesystem are propogated to the database by the nightly datman scripts.

## Creating a development environment

These instructions will create a development environment for the dashboard application.

1. Fork this repository

2. Clone your new fork

3. Create a OAuth application on GitHub
  * [GitHub instructions](https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/)
  * `Settings` --> `Developer Settings` --> `OAuth applications`
  * Click `Register a new application`
  * Fill in the name, url, description (these are not important)
  * Set the `Authorisation callback URL` to `http://<your computer name or ip>:5000/callback/github`
  * click continue (or whatever)
  * You will need the generated __Client ID__ and __Client Secret__ in the next steps.

4. `$ cp dashboard.module.template dashboard_dev.module`

5. Edit dashboard.module to include your new information. Other secret information can be obtained from passpack.

6. Load the datman environment
  * `$ module load /archive/code/datman/datman_env.module`

7. Load the dashboard environment
  * `$module load ./dashboard_dev.module`

8. Create a virtual environment for the dashboard and activate it before running the server.
`$ virtualenv -p /usr/bin/python2.7 venv
 $ source venv/bin/activate
 $ pip install -r requirements.txt`

9. Start the web application. run.py will give you a debugger when errors arise, but srv_uwsgi is what the production dashboard runs.
  * `$ python ./run.py` or `$./srv_uwsgi.py`

10. Enjoy


### Creating your own conda env
This isn't needed if you're on the kimel system. N.B. The production version of dashboard still uses a venv, not a conda env. `requirements.txt` should be used if this needs recreating.

1. `conda create --prefix ./dashboard_env --file create_conda.txt`
2. `pip install rauth PyCap`
3. `source activate dashboard_env/`

### Creating your own database

#### Install postgresql
```
$ sudo apt-get update
$ sudo apt-get install postgresql-9.5 postgresql-client-9.5 postgresql-contrib-9.5
```

#### Configure postgres to accept tcp connections
* Edit the file `/etc/postgresql/9.5/main/postgresql.conf` to include the line `listen_addresses = 'localhost'`
* Restart postgresql
  `sudo systemctl restart postgresql`
* Edit the file `/etc/postgresql/9.5/main/pg_hba.conf` to include:
```
host all all <yourip>/32 trust
host dashboard_dev web_user <yourip>/32 password
```

#### Create a user account
```
$ sudo -u postgres createuser -s <your_username>
```

#### Create an empty database
```
$ createdb -T template0 dashboard_dev
```

#### Create a backup of the production database
_N.B. This command requires your user to have appropriate permissions on the prodution server. See __Grant Admin Rights__ above._
```
$ pg_dump -h srv-postgres -d dashboard > ~/dashboard_dump.out
```

#### Restore the backup from the production db into the new blank db
```
$ psql dashboard_dev -f ~/dashboard_dump.out
```

### Update dashboard.module
Enter the new parameters into your local dashboard.module and reload
```
$ module load dashboard.module
```

### Adding a new study
For now, to add a new study to the dashboard you must manually insert some
records into the database.

1. If the PI of the study is not already in the table 'people', they must be added
2. A record must be added to the table 'studies'
3. Any sites unique to this study must be added to the 'sites'
4. For each site in the study make a record in study_sites
5. Add any unique series tags to scantypes
6. For each scantype tag that may appear in this study's data, add a record to study_scantypes

### Granting yourself access to the production database
Make sure pidentd is installed on your machine. Then ssh into srv-postgres as
a user with sudo powers and add a record for your own username to
/etc/postgresql/9.5/main/pg_ident.conf above the last line (the one with the regex).
You may need to restart the postgres daemon afterwards.
