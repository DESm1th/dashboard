# Readme for production version of dashboard webapp

## Overview

The dashboard webapp provides an overview of the studies supported by the kimel lab.
The app supports manual QC of MRI sessions, as well as display of various QC metrics generated by the automatic pipelines.

## Technologies

The app is supported by a backend [postgreSQL](https://www.postgresql.org/) database, hosted on the srv-postgres.camhres.ca virtual server.
Front end is programmed in python using the [Flask](http://flask.pocoo.org/) framework, with [SQLAlchemy](https://www.sqlalchemy.org/).

Web server is NGINX with UWSGI.

### Database

* *Server:* srv-postgres.camhres.ca (172.26.216.68)
* *Database:* dashboard

Server is **ansible** managed by role `/projects/admin/ansible-playbooks/roles/postgres`

Access requires postgresql client installed, authentication defaults to host authentication. This means _system users_ are mapped to postgresql _Roles_.

The **postgres** user (local machine) has SUPERUSER, by default other users have no access.

Three _roles_ have been defined with access to the dashboard database.

* **admin:** Manage databases, manage roles on all databases
* **dashboard:** Read, Write, Delete etc. on dashboard database
* **dashboard_read:** Read only on dashboard database

One special _user_ role has been defined. **web_user**, this is a member of the **dashboard** role and is used by the webapp front end.

**Clevis** is defined as a superuser to enable backups.

**N.B.** SQL commands are not case sensitive, but are normally terminated with a **; (semi-colon)**.

#### Backups
Backups are performed as user __clevis__ from a cron job `/etc/cron.d/ansible_postgres-backup` running on `srv_postgres`.
_Requires:_ `/mnt/backup` exported from tigrsrv, with a subdirectory `postgres` with write permission for user __clevis__.

##### Restoring from backup
```
$ psql -f /mnt/backup/postgres/postgres_YYYYMMDD.sql postgres
```

#### Grant admin rights to a user:

Required to manage other users.

```
$ ssh localadmin@srv-postgres
$ sudo su postgres
$ psql -d dashboard
dashboard=# GRANT admin TO <username>;
GRANT ROLE
dashboard=# \q
$
```

#### Grant Read only access to the dashboard database

To grant roles to other users, the current user must have the CREATE ROLE attribute, i.e. be a member of the _admin_ ROLE.

Once a user has been created in the database, access can be obtained from a local machine without requirement to ssh.

```
$ psql -h srv-postgres -d dashboard
dashboard=# GRANT dashboard_read TO <username>;
GRANT ROLE
dashboard=# \q
$
```

### Webserver

* **Server:** srv-dashboard.camhres.ca (172.26.216.66)

**NGINX** and **UWSGI** configuration are controlled by the ansible role `/projects/admin/ansible-playbooks/roles/dashboard/`.

The uwsgi app runs as user **clevis** with the **web_user** to access the database. These are configured in ```/etc/uwsgi/apps-available/dashboard.ini``` (Ansible controlled).

The codebase is expected to be located at `/archive/code/dashboard`.

*Important:* Some secret information is required in the ansible controlled file ``/etc/uwsgi/apps-available/dashboard.ini`. These entries should not be committed to github. The relevant passwords are in passpack.

#### Virtual env

The dashboard webapp depends on a python virtual env. Once the repo has been cloned from github create the virtual env and install the requirements.
```
$ git clone git@github.com:TIGRLab/dashboard.git dashboard
$ cd dashboard
$ virtualenv -p /usr/bin/python2.7 venv
$ source venv/bin/activate
$ pip install -r requirements.txt
```

### Web-app

**GitHub:** https://github.com/TIGRLab/dashboard

The app is written in python, using the Flask framework with SQLAlchemy.

#### Overview

`dashboard/models.py` defines the _Object Relational Mapping (ORM)_ used by SQLAlchemy to map from the relational database to the python objects used in the code.

`dashboard/views.py` defines the _entry points_ (i.e. valid URLs for the app).

HTML templates are in `dashboard/templates/`. Templates with `_snip.html` are embedded in other pages.

The web-app interacts with the filesystem (checklist.csv, blacklist.csv), updates made through the web-app are automatically propogated to the filesystem before the update is made. If the filesystem cannot be updated the database update fails.
Alterations made to the filesystem are propogated to the database by the nightly datman scripts.

## Creating a development environment

These instructions will create a development environment for the dashboard application.

1. Fork this repository

2. Clone your new fork

3. Create a OAuth application on GitHub
  * [GitHub instructions](https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/)
  * `Settings` --> `Developer Settings` --> `OAuth applications`
  * Click `Register a new application`
  * Fill in the name, url, description (these are not important)
  * Set the `Authorisation callback URL` to `http://<your computer name or ip>:5000/callback/github`
  * click continue (or whatever)
  * You will need the generated __Client ID__ and __Client Secret__ in the next steps.

4. `$ cp dashboard.module.template dashboard_dev.module`

5. Edit dashboard.module to include your new information. Other secret information can be obtained from passpack.

6. Activate the correct condas environment
  * `$ module load miniconda3`
  * `$ source activate dashboard`

7. Load the datman environment
  * `$ module load /archive/code/datman/datman_env.module`

8. Set the dashboard environment
  * `$module load ./dashboard_dev.module`

9. Start the web application
  * `$ python ./run.py` or `$./srv_uwsgi.py`

10. Enjoy


### Creating your own conda env
This isn't needed if your on the kimel system. N.B. The production version of dashboard still uses a venv, not a conda env. `requirements.txt` should be used if this needs recreating.

1. `conda create --prefix ./dashboard_env --file create_conda.txt`
2. `pip install rauth PyCap`
3. `source activate dashboard_env/`

### Creating your own database

#### Install postgresql
```
$ sudo apt-get update
$ sudo apt-get install postgresql-9.5 postgresql-client-9.5 postgresql-contrib-9.5
```

#### Configure postgres to accept tcp connections
* Edit the file `/etc/postgresql/9.5/main/postgresql.conf` to include the line `listen_addresses = 'localhost'`
* Restart postgresql
  `sudo systemctl restart postgresql`
* Edit the file `/etc/postgresql/9.5/main/pg_hba.conf` to include:
```
host all all <yourip>/32 trust
host dashboard_dev web_user <yourip>/32 password
```

#### Create a user account
```
$ sudo -u postgres createuser -s <your_username>
```

#### Create an empty database
```
$ createdb -T template0 dashboard_dev
```

#### Create a backup of the production database
_N.B. This command requires your user to have appropriate permissions on the prodution server. See __Grant Admin Rights__ above._
```
$ pg_dump -h srv-postgres -d dashboard > ~/dashboard_dump.out
```

#### Restore the backup from the production db into the new blank db
```
$ psql dashboard_dev -f ~/dashboard_dump.out
```

### Update dashboard.module
Enter the new parameters into your local dashboard.module and reload
```
$ module load dashboard.module
```

### Adding a new study
For now, to add a new study to the dashboard you must manually insert some
records into the database.

1. If the PI of the study is not already in the table 'people', they must be added
2. A record must be added to the table 'studies'
3. Any sites unique to this study must be added to the 'sites'
4. For each site in the study make a record in study_sites
5. Add any unique series tags to scantypes
6. For each scantype tag that may appear in this study's data, add a record to study_scantypes

### Granting yourself access to the production database
Make sure pidentd is installed on your machine. Then ssh into srv-postgres as
a user with sudo powers and add a record for your own username to
/etc/postgresql/9.5/main/pg_ident.conf above the last line (the one with the regex).
You may need to restart the postgres daemon afterwards.
